/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Actor, HttpAgent, type HttpAgentOptions, type ActorConfig, type Agent, type ActorSubclass } from "@icp-sdk/core/agent";
import type { Principal } from "@icp-sdk/core/principal";
import { idlFactory, type _SERVICE } from "./declarations/backend.did";
export interface Some<T> {
    __kind__: "Some";
    value: T;
}
export interface None {
    __kind__: "None";
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
    return {
        __kind__: "Some",
        value: value
    };
}
function none(): None {
    return {
        __kind__: "None"
    };
}
function isNone<T>(option: Option<T>): option is None {
    return option.__kind__ === "None";
}
function isSome<T>(option: Option<T>): option is Some<T> {
    return option.__kind__ === "Some";
}
function unwrap<T>(option: Option<T>): T {
    if (isNone(option)) {
        throw new Error("unwrap: none");
    }
    return option.value;
}
function candid_some<T>(value: T): [T] {
    return [
        value
    ];
}
function candid_none<T>(): [] {
    return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
    return arg == null ? undefined : arg;
}
export class ExternalBlob {
    _blob?: Uint8Array<ArrayBuffer> | null;
    directURL: string;
    onProgress?: (percentage: number) => void = undefined;
    private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null){
        if (blob) {
            this._blob = blob;
        }
        this.directURL = directURL;
    }
    static fromURL(url: string): ExternalBlob {
        return new ExternalBlob(url, null);
    }
    static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
        const url = URL.createObjectURL(new Blob([
            new Uint8Array(blob)
        ], {
            type: 'application/octet-stream'
        }));
        return new ExternalBlob(url, blob);
    }
    public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
        if (this._blob) {
            return this._blob;
        }
        const response = await fetch(this.directURL);
        const blob = await response.blob();
        this._blob = new Uint8Array(await blob.arrayBuffer());
        return this._blob;
    }
    public getDirectURL(): string {
        return this.directURL;
    }
    public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
        this.onProgress = onProgress;
        return this;
    }
}
export interface UserProfile {
    name: string;
}
export interface AgentConfig {
    issueDate: bigint;
    status: AgentStatus;
    maxSessions?: bigint;
    expiryTimestamp: bigint;
    approvalRequired: boolean;
    capabilities: Array<string>;
    name: string;
    roleDescription: string;
    policyScope: string;
    verificationStatus: VerificationStatus;
    maxBudget: bigint;
}
export type Time = bigint;
export interface _CaffeineStorageRefillInformation {
    proposed_top_up_amount?: bigint;
}
export interface MetricsSummary {
    startTime: bigint;
    totalTasks: bigint;
    completedTasks: bigint;
    endTime: bigint;
    agentId: Principal;
    complianceScore: number;
    pendingTasks: bigint;
}
export interface NotarizationRecord {
    id: bigint;
    contentHash?: Uint8Array;
    contentText?: string;
    owner: Principal;
    timestamp: bigint;
}
export interface _CaffeineStorageCreateCertificateResult {
    method: string;
    blob_hash: string;
}
export interface CommunityTopic {
    id: bigint;
    title: string;
    content: string;
    author: Principal;
    timestamp: bigint;
    replyCount: bigint;
}
export interface EvidenceItem {
    id: bigint;
    owner: Principal;
    notarizationRecordId?: bigint;
    description: string;
    timestamp: bigint;
}
export interface TradeOrder {
    id: bigint;
    status: Variant_cancelled_open_filled;
    user: Principal;
    orderType: Variant_buy_sell;
    timestamp: bigint;
    tokenPair: string;
    price: bigint;
    amount: bigint;
}
export interface AgentDesignState {
    name: string;
    roleDescription: string;
}
export type TokenOperation = {
    __kind__: "trade";
    trade: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        fromToken: bigint;
        amount: bigint;
        toToken: bigint;
    };
} | {
    __kind__: "burn";
    burn: {
        timestamp: bigint;
        amount: bigint;
    };
} | {
    __kind__: "mint";
    mint: {
        to: Principal;
        timestamp: bigint;
        amount: bigint;
    };
} | {
    __kind__: "transfer";
    transfer: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        amount: bigint;
    };
} | {
    __kind__: "conversion";
    conversion: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        fromToken: bigint;
        amount: bigint;
        toToken: bigint;
    };
};
export interface RoadmapItem {
    id: bigint;
    assignedTo: Principal;
    highPriority: boolean;
    description: string;
    lowPriority: boolean;
    category: string;
}
export interface SharedAgentDesignState {
    name: string;
    roleDescription: string;
}
export interface RegistryEntry {
    content: string;
    additions: string;
}
export interface WorkflowRun {
    id: bigint;
    evidenceItemIds: Array<bigint>;
    owner: Principal;
    name: string;
    description: string;
    timestamp: bigint;
}
export interface MarketplaceUnlock {
    itemId: bigint;
    user: Principal;
    timestamp: bigint;
}
export interface RewardEvent {
    id: bigint;
    user: Principal;
    description: string;
    timestamp: bigint;
    points: bigint;
}
export interface UserRoadmap {
    highPriority: Array<RoadmapItem>;
    mediumPriority: Array<RoadmapItem>;
    lowPriority: Array<RoadmapItem>;
}
export interface PolicyRule {
    ruleType: string;
    active: boolean;
    name: string;
    description: string;
    enforced: boolean;
    scope: string;
    criteria?: string;
    expiry?: bigint;
    allowedActions: Array<string>;
}
export interface DebugRoleResult {
    roleMapValue?: Role;
    callerText: string;
    isAdmin: boolean;
}
export interface Trade {
    id: bigint;
    sellOrderId: bigint;
    buyOrderId: bigint;
    timestamp: bigint;
    tokenPair: string;
    price: bigint;
    amount: bigint;
}
export interface TokenDistribution {
    miningTokens: bigint;
    timeAiTokens: bigint;
    timeTokens: bigint;
    travAiTokens: bigint;
    travTokens: bigint;
}
export interface CommunityReply {
    id: bigint;
    content: string;
    author: Principal;
    timestamp: bigint;
    topicId: bigint;
}
export interface TimeSeriesEntry {
    completedTasks: bigint;
    timestamp: bigint;
    complianceScore: number;
}
export interface MarketplaceItem {
    id: bigint;
    title: string;
    description: string;
    price: bigint;
}
export interface NotaryRequest {
    contentText: string;
}
export interface _CaffeineStorageRefillResult {
    success?: boolean;
    topped_up_amount?: bigint;
}
export interface EnterpriseOnboardingRequest {
    id: bigint;
    contract: string;
    user: Principal;
    company: string;
    onboardingStatus: Variant_pending_approved_rejected;
    notes: string;
    timestamp: Time;
}
export enum AgentStatus {
    active = "active",
    pending = "pending",
    suspended = "suspended"
}
export enum LabelSetState {
    notFreezed = "notFreezed",
    freezed = "freezed"
}
export enum Role {
    admin = "admin",
    user = "user"
}
export enum UserRole {
    admin = "admin",
    user = "user",
    guest = "guest"
}
export enum Variant_buy_sell {
    buy = "buy",
    sell = "sell"
}
export enum Variant_cancelled_open_filled {
    cancelled = "cancelled",
    open = "open",
    filled = "filled"
}
export enum Variant_pending_approved_rejected {
    pending = "pending",
    approved = "approved",
    rejected = "rejected"
}
export enum VerificationStatus {
    verified = "verified",
    pending = "pending",
    unverified = "unverified",
    suspended = "suspended"
}
export interface backendInterface {
    _caffeineStorageBlobIsLive(hash: Uint8Array): Promise<boolean>;
    _caffeineStorageBlobsToDelete(): Promise<Array<Uint8Array>>;
    _caffeineStorageConfirmBlobDeletion(blobs: Array<Uint8Array>): Promise<void>;
    _caffeineStorageCreateCertificate(blobHash: string): Promise<_CaffeineStorageCreateCertificateResult>;
    _caffeineStorageRefillCashier(refillInformation: _CaffeineStorageRefillInformation | null): Promise<_CaffeineStorageRefillResult>;
    _caffeineStorageUpdateGatewayPrincipals(): Promise<void>;
    _initializeAccessControlWithSecret(userSecret: string): Promise<void>;
    addCommunityReply(topicId: bigint, content: string): Promise<void>;
    addRegistryEntry(content: string, additions: string): Promise<void>;
    assignCallerUserRole(user: Principal, role: UserRole): Promise<void>;
    assignRoadmapItemToUser(itemId: bigint, user: Principal): Promise<void>;
    cancelTradeOrder(orderId: bigint): Promise<void>;
    createAgentDesign(agentDesign: SharedAgentDesignState): Promise<void>;
    createCommunityTopic(title: string, content: string): Promise<bigint>;
    createEvidenceItem(description: string, notarizationRecordId: bigint | null): Promise<EvidenceItem>;
    createMarketplaceItem(item: MarketplaceItem): Promise<void>;
    createPolicyRule(rule: PolicyRule): Promise<void>;
    createRoadmapItem(item: RoadmapItem): Promise<void>;
    createUserRoadmap(high: Array<RoadmapItem>, medium: Array<RoadmapItem>, low: Array<RoadmapItem>): Promise<void>;
    createWorkflowRun(name: string, description: string, evidenceItemIds: Array<bigint>): Promise<WorkflowRun>;
    debugCaller(): Promise<string>;
    debugListUsers(): Promise<Array<Principal>>;
    debugRole(): Promise<DebugRoleResult>;
    deleteAgentDesign(id: bigint): Promise<void>;
    deleteMarketplaceItem(id: bigint): Promise<void>;
    deletePolicyRule(id: bigint): Promise<void>;
    deleteRoadmapItem(id: bigint): Promise<void>;
    earnRewardPoints(points: bigint, description: string): Promise<void>;
    ensureCallerUserExists(): Promise<string>;
    executeTrade(buyOrderId: bigint, sellOrderId: bigint): Promise<void>;
    forceAdmin(): Promise<string>;
    freezeLabelSet(): Promise<void>;
    getAgentDesigns(): Promise<Array<AgentDesignState>>;
    getAgentMetricsSummary(agentId: Principal, startTime: bigint, endTime: bigint): Promise<MetricsSummary>;
    getAgentTimeSeries(agentId: Principal, startTime: bigint, endTime: bigint, interval: bigint): Promise<Array<TimeSeriesEntry>>;
    getAllAgentConfigs(): Promise<Array<AgentConfig>>;
    getAllEnterpriseOnboardingRequests(): Promise<Array<EnterpriseOnboardingRequest>>;
    getAllNotarizationRecords(): Promise<Array<NotarizationRecord>>;
    getAllUsers(): Promise<Array<[Principal, Role]>>;
    getCallerUserProfile(): Promise<UserProfile | null>;
    getCallerUserRole(): Promise<UserRole>;
    getCommunityReplies(topicId: bigint): Promise<Array<CommunityReply>>;
    getCommunityTopic(id: bigint): Promise<CommunityTopic | null>;
    getCommunityTopics(): Promise<Array<CommunityTopic>>;
    getComplianceLog(forceHistoricalAnalysis: boolean): Promise<Array<TokenOperation>>;
    getCurrentUserRoadmap(): Promise<UserRoadmap>;
    getEnterpriseRequest(id: bigint): Promise<EnterpriseOnboardingRequest | null>;
    getEvidenceItem(id: bigint): Promise<EvidenceItem | null>;
    getEvidenceItems(): Promise<Array<EvidenceItem>>;
    getLabelSetState(): Promise<LabelSetState>;
    getMarketPrice(forceHistoricalAnalysis: boolean): Promise<{
        timestamp: bigint;
        market: bigint;
        priceUSDT: bigint;
    }>;
    getMarketplaceItemById(id: bigint): Promise<MarketplaceItem | null>;
    getMarketplaceItems(): Promise<Array<MarketplaceItem>>;
    getMyAgentConfigs(): Promise<Array<AgentConfig>>;
    getMyEnterpriseOnboardingRequests(): Promise<Array<EnterpriseOnboardingRequest>>;
    getMyMarketplaceUnlocks(): Promise<Array<MarketplaceUnlock>>;
    getMyNotarizationRecords(): Promise<Array<NotarizationRecord>>;
    getMyOpenOrders(): Promise<Array<TradeOrder>>;
    getMyRewardEvents(): Promise<Array<RewardEvent>>;
    getMyRewardPoints(): Promise<bigint>;
    getMyRoadmapItems(): Promise<Array<RoadmapItem>>;
    getMyRole(): Promise<string>;
    getMyUserExists(): Promise<boolean>;
    getPolicyRuleById(id: bigint): Promise<PolicyRule | null>;
    getPolicyRules(): Promise<Array<PolicyRule>>;
    getRecentTrades(): Promise<Array<Trade>>;
    getRegistryEntries(): Promise<Array<RegistryEntry>>;
    getRoadmapItem(id: bigint): Promise<RoadmapItem>;
    getRoadmapItems(): Promise<Array<RoadmapItem>>;
    getRoadmapItemsForUser(userId: Principal): Promise<Array<RoadmapItem>>;
    getSubscription(user: Principal): Promise<string>;
    getTokenBurnAnalysisMultiSeries(forceHistoricalAnalysis: boolean): Promise<Array<TokenOperation>>;
    getTokenBurnAnalysisSingleSeries(forceHistoricalAnalysis: boolean): Promise<{
        tokensMinted: bigint;
        tokensCirculating: bigint;
        revenueRetainedUSDT: bigint;
        tokensBurned: bigint;
    }>;
    getUserCount(): Promise<bigint>;
    getUserProfile(user: Principal): Promise<UserProfile | null>;
    getUserRoadmap(user: Principal): Promise<UserRoadmap>;
    getWorkflowRun(id: bigint): Promise<WorkflowRun | null>;
    getWorkflowRunEvidence(workflowRunId: bigint): Promise<Array<EvidenceItem>>;
    getWorkflowRuns(): Promise<Array<WorkflowRun>>;
    initializeAdmin(): Promise<string>;
    isCallerAdmin(): Promise<boolean>;
    listTokenDistributions(forceHistoricalAnalysis: boolean): Promise<{
        timeTokenDistributions?: TokenDistribution;
        travAiTokenDistributions?: TokenDistribution;
        travTokenDistributions?: TokenDistribution;
        timeAiTokenDistributions?: TokenDistribution;
        miningTokenDistributions?: TokenDistribution;
    }>;
    logTaskCompletion(agentId: Principal, taskId: bigint, completed: boolean): Promise<void>;
    placeTradeOrder(orderType: Variant_buy_sell, tokenPair: string, amount: bigint, price: bigint): Promise<bigint>;
    redeemRewardPoints(points: bigint, description: string): Promise<void>;
    registerAgentConfig(config: AgentConfig): Promise<void>;
    registerSelf(): Promise<string>;
    saveCallerUserProfile(profile: UserProfile): Promise<void>;
    setSubscription(user: Principal, tier: string): Promise<void>;
    submitEnterpriseOnboardingRequest(company: string, contract: string): Promise<bigint>;
    submitNotaryRequest(request: NotaryRequest): Promise<NotarizationRecord>;
    unlockMarketplaceItem(itemId: bigint): Promise<void>;
    updateAgentConfigs(config: AgentConfig): Promise<void>;
    updateAgentDesign(id: bigint, agentUpdate: SharedAgentDesignState): Promise<void>;
    updateAgentStatus(arg0: bigint, arg1: AgentStatus): Promise<void>;
    updateAgentVerificationStatus(agentId: Principal, configId: bigint, verificationStatus: VerificationStatus): Promise<void>;
    updateEnterpriseRequestStatus(id: bigint, status: Variant_pending_approved_rejected, notes: string): Promise<void>;
    updateMarketplaceItem(id: bigint, item: MarketplaceItem): Promise<void>;
    updatePolicyRule(id: bigint, rule: PolicyRule): Promise<void>;
    updateRoadmapItem(id: bigint, item: RoadmapItem): Promise<void>;
    verifyNotarizationHash(hash: Uint8Array): Promise<NotarizationRecord | null>;
    verifyNotarizationText(text: string): Promise<NotarizationRecord | null>;
    whoami(): Promise<string>;
}
import type { AgentConfig as _AgentConfig, AgentStatus as _AgentStatus, CommunityTopic as _CommunityTopic, DebugRoleResult as _DebugRoleResult, EnterpriseOnboardingRequest as _EnterpriseOnboardingRequest, EvidenceItem as _EvidenceItem, LabelSetState as _LabelSetState, MarketplaceItem as _MarketplaceItem, NotarizationRecord as _NotarizationRecord, PolicyRule as _PolicyRule, Role as _Role, Time as _Time, TokenDistribution as _TokenDistribution, TokenOperation as _TokenOperation, TradeOrder as _TradeOrder, UserProfile as _UserProfile, UserRole as _UserRole, VerificationStatus as _VerificationStatus, WorkflowRun as _WorkflowRun, _CaffeineStorageRefillInformation as __CaffeineStorageRefillInformation, _CaffeineStorageRefillResult as __CaffeineStorageRefillResult } from "./declarations/backend.did.d.ts";
export class Backend implements backendInterface {
    constructor(private actor: ActorSubclass<_SERVICE>, private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, private processError?: (error: unknown) => never){}
    async _caffeineStorageBlobIsLive(arg0: Uint8Array): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor._caffeineStorageBlobIsLive(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._caffeineStorageBlobIsLive(arg0);
            return result;
        }
    }
    async _caffeineStorageBlobsToDelete(): Promise<Array<Uint8Array>> {
        if (this.processError) {
            try {
                const result = await this.actor._caffeineStorageBlobsToDelete();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._caffeineStorageBlobsToDelete();
            return result;
        }
    }
    async _caffeineStorageConfirmBlobDeletion(arg0: Array<Uint8Array>): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._caffeineStorageConfirmBlobDeletion(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._caffeineStorageConfirmBlobDeletion(arg0);
            return result;
        }
    }
    async _caffeineStorageCreateCertificate(arg0: string): Promise<_CaffeineStorageCreateCertificateResult> {
        if (this.processError) {
            try {
                const result = await this.actor._caffeineStorageCreateCertificate(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._caffeineStorageCreateCertificate(arg0);
            return result;
        }
    }
    async _caffeineStorageRefillCashier(arg0: _CaffeineStorageRefillInformation | null): Promise<_CaffeineStorageRefillResult> {
        if (this.processError) {
            try {
                const result = await this.actor._caffeineStorageRefillCashier(to_candid_opt_n1(this._uploadFile, this._downloadFile, arg0));
                return from_candid__CaffeineStorageRefillResult_n4(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._caffeineStorageRefillCashier(to_candid_opt_n1(this._uploadFile, this._downloadFile, arg0));
            return from_candid__CaffeineStorageRefillResult_n4(this._uploadFile, this._downloadFile, result);
        }
    }
    async _caffeineStorageUpdateGatewayPrincipals(): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._caffeineStorageUpdateGatewayPrincipals();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._caffeineStorageUpdateGatewayPrincipals();
            return result;
        }
    }
    async _initializeAccessControlWithSecret(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._initializeAccessControlWithSecret(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._initializeAccessControlWithSecret(arg0);
            return result;
        }
    }
    async addCommunityReply(arg0: bigint, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addCommunityReply(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addCommunityReply(arg0, arg1);
            return result;
        }
    }
    async addRegistryEntry(arg0: string, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addRegistryEntry(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addRegistryEntry(arg0, arg1);
            return result;
        }
    }
    async assignCallerUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n8(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n8(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async assignRoadmapItemToUser(arg0: bigint, arg1: Principal): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.assignRoadmapItemToUser(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.assignRoadmapItemToUser(arg0, arg1);
            return result;
        }
    }
    async cancelTradeOrder(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.cancelTradeOrder(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.cancelTradeOrder(arg0);
            return result;
        }
    }
    async createAgentDesign(arg0: SharedAgentDesignState): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.createAgentDesign(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createAgentDesign(arg0);
            return result;
        }
    }
    async createCommunityTopic(arg0: string, arg1: string): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.createCommunityTopic(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createCommunityTopic(arg0, arg1);
            return result;
        }
    }
    async createEvidenceItem(arg0: string, arg1: bigint | null): Promise<EvidenceItem> {
        if (this.processError) {
            try {
                const result = await this.actor.createEvidenceItem(arg0, to_candid_opt_n10(this._uploadFile, this._downloadFile, arg1));
                return from_candid_EvidenceItem_n11(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createEvidenceItem(arg0, to_candid_opt_n10(this._uploadFile, this._downloadFile, arg1));
            return from_candid_EvidenceItem_n11(this._uploadFile, this._downloadFile, result);
        }
    }
    async createMarketplaceItem(arg0: MarketplaceItem): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.createMarketplaceItem(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createMarketplaceItem(arg0);
            return result;
        }
    }
    async createPolicyRule(arg0: PolicyRule): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.createPolicyRule(to_candid_PolicyRule_n13(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createPolicyRule(to_candid_PolicyRule_n13(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async createRoadmapItem(arg0: RoadmapItem): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.createRoadmapItem(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createRoadmapItem(arg0);
            return result;
        }
    }
    async createUserRoadmap(arg0: Array<RoadmapItem>, arg1: Array<RoadmapItem>, arg2: Array<RoadmapItem>): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.createUserRoadmap(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createUserRoadmap(arg0, arg1, arg2);
            return result;
        }
    }
    async createWorkflowRun(arg0: string, arg1: string, arg2: Array<bigint>): Promise<WorkflowRun> {
        if (this.processError) {
            try {
                const result = await this.actor.createWorkflowRun(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createWorkflowRun(arg0, arg1, arg2);
            return result;
        }
    }
    async debugCaller(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.debugCaller();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.debugCaller();
            return result;
        }
    }
    async debugListUsers(): Promise<Array<Principal>> {
        if (this.processError) {
            try {
                const result = await this.actor.debugListUsers();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.debugListUsers();
            return result;
        }
    }
    async debugRole(): Promise<DebugRoleResult> {
        if (this.processError) {
            try {
                const result = await this.actor.debugRole();
                return from_candid_DebugRoleResult_n15(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.debugRole();
            return from_candid_DebugRoleResult_n15(this._uploadFile, this._downloadFile, result);
        }
    }
    async deleteAgentDesign(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteAgentDesign(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteAgentDesign(arg0);
            return result;
        }
    }
    async deleteMarketplaceItem(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteMarketplaceItem(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteMarketplaceItem(arg0);
            return result;
        }
    }
    async deletePolicyRule(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deletePolicyRule(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deletePolicyRule(arg0);
            return result;
        }
    }
    async deleteRoadmapItem(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteRoadmapItem(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteRoadmapItem(arg0);
            return result;
        }
    }
    async earnRewardPoints(arg0: bigint, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.earnRewardPoints(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.earnRewardPoints(arg0, arg1);
            return result;
        }
    }
    async ensureCallerUserExists(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.ensureCallerUserExists();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.ensureCallerUserExists();
            return result;
        }
    }
    async executeTrade(arg0: bigint, arg1: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.executeTrade(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.executeTrade(arg0, arg1);
            return result;
        }
    }
    async forceAdmin(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.forceAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.forceAdmin();
            return result;
        }
    }
    async freezeLabelSet(): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.freezeLabelSet();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.freezeLabelSet();
            return result;
        }
    }
    async getAgentDesigns(): Promise<Array<AgentDesignState>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAgentDesigns();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAgentDesigns();
            return result;
        }
    }
    async getAgentMetricsSummary(arg0: Principal, arg1: bigint, arg2: bigint): Promise<MetricsSummary> {
        if (this.processError) {
            try {
                const result = await this.actor.getAgentMetricsSummary(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAgentMetricsSummary(arg0, arg1, arg2);
            return result;
        }
    }
    async getAgentTimeSeries(arg0: Principal, arg1: bigint, arg2: bigint, arg3: bigint): Promise<Array<TimeSeriesEntry>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAgentTimeSeries(arg0, arg1, arg2, arg3);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAgentTimeSeries(arg0, arg1, arg2, arg3);
            return result;
        }
    }
    async getAllAgentConfigs(): Promise<Array<AgentConfig>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllAgentConfigs();
                return from_candid_vec_n20(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllAgentConfigs();
            return from_candid_vec_n20(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAllEnterpriseOnboardingRequests(): Promise<Array<EnterpriseOnboardingRequest>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllEnterpriseOnboardingRequests();
                return from_candid_vec_n27(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllEnterpriseOnboardingRequests();
            return from_candid_vec_n27(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAllNotarizationRecords(): Promise<Array<NotarizationRecord>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllNotarizationRecords();
                return from_candid_vec_n31(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllNotarizationRecords();
            return from_candid_vec_n31(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAllUsers(): Promise<Array<[Principal, Role]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllUsers();
                return from_candid_vec_n36(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllUsers();
            return from_candid_vec_n36(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserProfile(): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserProfile();
                return from_candid_opt_n38(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserProfile();
            return from_candid_opt_n38(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserRole(): Promise<UserRole> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserRole();
                return from_candid_UserRole_n39(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserRole();
            return from_candid_UserRole_n39(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCommunityReplies(arg0: bigint): Promise<Array<CommunityReply>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCommunityReplies(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCommunityReplies(arg0);
            return result;
        }
    }
    async getCommunityTopic(arg0: bigint): Promise<CommunityTopic | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getCommunityTopic(arg0);
                return from_candid_opt_n41(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCommunityTopic(arg0);
            return from_candid_opt_n41(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCommunityTopics(): Promise<Array<CommunityTopic>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCommunityTopics();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCommunityTopics();
            return result;
        }
    }
    async getComplianceLog(arg0: boolean): Promise<Array<TokenOperation>> {
        if (this.processError) {
            try {
                const result = await this.actor.getComplianceLog(arg0);
                return from_candid_vec_n42(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getComplianceLog(arg0);
            return from_candid_vec_n42(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCurrentUserRoadmap(): Promise<UserRoadmap> {
        if (this.processError) {
            try {
                const result = await this.actor.getCurrentUserRoadmap();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCurrentUserRoadmap();
            return result;
        }
    }
    async getEnterpriseRequest(arg0: bigint): Promise<EnterpriseOnboardingRequest | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getEnterpriseRequest(arg0);
                return from_candid_opt_n45(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getEnterpriseRequest(arg0);
            return from_candid_opt_n45(this._uploadFile, this._downloadFile, result);
        }
    }
    async getEvidenceItem(arg0: bigint): Promise<EvidenceItem | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getEvidenceItem(arg0);
                return from_candid_opt_n46(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getEvidenceItem(arg0);
            return from_candid_opt_n46(this._uploadFile, this._downloadFile, result);
        }
    }
    async getEvidenceItems(): Promise<Array<EvidenceItem>> {
        if (this.processError) {
            try {
                const result = await this.actor.getEvidenceItems();
                return from_candid_vec_n47(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getEvidenceItems();
            return from_candid_vec_n47(this._uploadFile, this._downloadFile, result);
        }
    }
    async getLabelSetState(): Promise<LabelSetState> {
        if (this.processError) {
            try {
                const result = await this.actor.getLabelSetState();
                return from_candid_LabelSetState_n48(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getLabelSetState();
            return from_candid_LabelSetState_n48(this._uploadFile, this._downloadFile, result);
        }
    }
    async getMarketPrice(arg0: boolean): Promise<{
        timestamp: bigint;
        market: bigint;
        priceUSDT: bigint;
    }> {
        if (this.processError) {
            try {
                const result = await this.actor.getMarketPrice(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMarketPrice(arg0);
            return result;
        }
    }
    async getMarketplaceItemById(arg0: bigint): Promise<MarketplaceItem | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getMarketplaceItemById(arg0);
                return from_candid_opt_n50(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMarketplaceItemById(arg0);
            return from_candid_opt_n50(this._uploadFile, this._downloadFile, result);
        }
    }
    async getMarketplaceItems(): Promise<Array<MarketplaceItem>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMarketplaceItems();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMarketplaceItems();
            return result;
        }
    }
    async getMyAgentConfigs(): Promise<Array<AgentConfig>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyAgentConfigs();
                return from_candid_vec_n20(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyAgentConfigs();
            return from_candid_vec_n20(this._uploadFile, this._downloadFile, result);
        }
    }
    async getMyEnterpriseOnboardingRequests(): Promise<Array<EnterpriseOnboardingRequest>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyEnterpriseOnboardingRequests();
                return from_candid_vec_n27(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyEnterpriseOnboardingRequests();
            return from_candid_vec_n27(this._uploadFile, this._downloadFile, result);
        }
    }
    async getMyMarketplaceUnlocks(): Promise<Array<MarketplaceUnlock>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyMarketplaceUnlocks();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyMarketplaceUnlocks();
            return result;
        }
    }
    async getMyNotarizationRecords(): Promise<Array<NotarizationRecord>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyNotarizationRecords();
                return from_candid_vec_n31(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyNotarizationRecords();
            return from_candid_vec_n31(this._uploadFile, this._downloadFile, result);
        }
    }
    async getMyOpenOrders(): Promise<Array<TradeOrder>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyOpenOrders();
                return from_candid_vec_n51(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyOpenOrders();
            return from_candid_vec_n51(this._uploadFile, this._downloadFile, result);
        }
    }
    async getMyRewardEvents(): Promise<Array<RewardEvent>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyRewardEvents();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyRewardEvents();
            return result;
        }
    }
    async getMyRewardPoints(): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyRewardPoints();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyRewardPoints();
            return result;
        }
    }
    async getMyRoadmapItems(): Promise<Array<RoadmapItem>> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyRoadmapItems();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyRoadmapItems();
            return result;
        }
    }
    async getMyRole(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyRole();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyRole();
            return result;
        }
    }
    async getMyUserExists(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.getMyUserExists();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getMyUserExists();
            return result;
        }
    }
    async getPolicyRuleById(arg0: bigint): Promise<PolicyRule | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getPolicyRuleById(arg0);
                return from_candid_opt_n56(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPolicyRuleById(arg0);
            return from_candid_opt_n56(this._uploadFile, this._downloadFile, result);
        }
    }
    async getPolicyRules(): Promise<Array<PolicyRule>> {
        if (this.processError) {
            try {
                const result = await this.actor.getPolicyRules();
                return from_candid_vec_n60(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPolicyRules();
            return from_candid_vec_n60(this._uploadFile, this._downloadFile, result);
        }
    }
    async getRecentTrades(): Promise<Array<Trade>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRecentTrades();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRecentTrades();
            return result;
        }
    }
    async getRegistryEntries(): Promise<Array<RegistryEntry>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRegistryEntries();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRegistryEntries();
            return result;
        }
    }
    async getRoadmapItem(arg0: bigint): Promise<RoadmapItem> {
        if (this.processError) {
            try {
                const result = await this.actor.getRoadmapItem(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRoadmapItem(arg0);
            return result;
        }
    }
    async getRoadmapItems(): Promise<Array<RoadmapItem>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRoadmapItems();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRoadmapItems();
            return result;
        }
    }
    async getRoadmapItemsForUser(arg0: Principal): Promise<Array<RoadmapItem>> {
        if (this.processError) {
            try {
                const result = await this.actor.getRoadmapItemsForUser(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getRoadmapItemsForUser(arg0);
            return result;
        }
    }
    async getSubscription(arg0: Principal): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.getSubscription(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getSubscription(arg0);
            return result;
        }
    }
    async getTokenBurnAnalysisMultiSeries(arg0: boolean): Promise<Array<TokenOperation>> {
        if (this.processError) {
            try {
                const result = await this.actor.getTokenBurnAnalysisMultiSeries(arg0);
                return from_candid_vec_n42(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTokenBurnAnalysisMultiSeries(arg0);
            return from_candid_vec_n42(this._uploadFile, this._downloadFile, result);
        }
    }
    async getTokenBurnAnalysisSingleSeries(arg0: boolean): Promise<{
        tokensMinted: bigint;
        tokensCirculating: bigint;
        revenueRetainedUSDT: bigint;
        tokensBurned: bigint;
    }> {
        if (this.processError) {
            try {
                const result = await this.actor.getTokenBurnAnalysisSingleSeries(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTokenBurnAnalysisSingleSeries(arg0);
            return result;
        }
    }
    async getUserCount(): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserCount();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserCount();
            return result;
        }
    }
    async getUserProfile(arg0: Principal): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserProfile(arg0);
                return from_candid_opt_n38(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserProfile(arg0);
            return from_candid_opt_n38(this._uploadFile, this._downloadFile, result);
        }
    }
    async getUserRoadmap(arg0: Principal): Promise<UserRoadmap> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserRoadmap(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserRoadmap(arg0);
            return result;
        }
    }
    async getWorkflowRun(arg0: bigint): Promise<WorkflowRun | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getWorkflowRun(arg0);
                return from_candid_opt_n61(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getWorkflowRun(arg0);
            return from_candid_opt_n61(this._uploadFile, this._downloadFile, result);
        }
    }
    async getWorkflowRunEvidence(arg0: bigint): Promise<Array<EvidenceItem>> {
        if (this.processError) {
            try {
                const result = await this.actor.getWorkflowRunEvidence(arg0);
                return from_candid_vec_n47(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getWorkflowRunEvidence(arg0);
            return from_candid_vec_n47(this._uploadFile, this._downloadFile, result);
        }
    }
    async getWorkflowRuns(): Promise<Array<WorkflowRun>> {
        if (this.processError) {
            try {
                const result = await this.actor.getWorkflowRuns();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getWorkflowRuns();
            return result;
        }
    }
    async initializeAdmin(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.initializeAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.initializeAdmin();
            return result;
        }
    }
    async isCallerAdmin(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.isCallerAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.isCallerAdmin();
            return result;
        }
    }
    async listTokenDistributions(arg0: boolean): Promise<{
        timeTokenDistributions?: TokenDistribution;
        travAiTokenDistributions?: TokenDistribution;
        travTokenDistributions?: TokenDistribution;
        timeAiTokenDistributions?: TokenDistribution;
        miningTokenDistributions?: TokenDistribution;
    }> {
        if (this.processError) {
            try {
                const result = await this.actor.listTokenDistributions(arg0);
                return from_candid_record_n62(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listTokenDistributions(arg0);
            return from_candid_record_n62(this._uploadFile, this._downloadFile, result);
        }
    }
    async logTaskCompletion(arg0: Principal, arg1: bigint, arg2: boolean): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.logTaskCompletion(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.logTaskCompletion(arg0, arg1, arg2);
            return result;
        }
    }
    async placeTradeOrder(arg0: Variant_buy_sell, arg1: string, arg2: bigint, arg3: bigint): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.placeTradeOrder(to_candid_variant_n64(this._uploadFile, this._downloadFile, arg0), arg1, arg2, arg3);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.placeTradeOrder(to_candid_variant_n64(this._uploadFile, this._downloadFile, arg0), arg1, arg2, arg3);
            return result;
        }
    }
    async redeemRewardPoints(arg0: bigint, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.redeemRewardPoints(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.redeemRewardPoints(arg0, arg1);
            return result;
        }
    }
    async registerAgentConfig(arg0: AgentConfig): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.registerAgentConfig(to_candid_AgentConfig_n65(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.registerAgentConfig(to_candid_AgentConfig_n65(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async registerSelf(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.registerSelf();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.registerSelf();
            return result;
        }
    }
    async saveCallerUserProfile(arg0: UserProfile): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveCallerUserProfile(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveCallerUserProfile(arg0);
            return result;
        }
    }
    async setSubscription(arg0: Principal, arg1: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.setSubscription(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.setSubscription(arg0, arg1);
            return result;
        }
    }
    async submitEnterpriseOnboardingRequest(arg0: string, arg1: string): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.submitEnterpriseOnboardingRequest(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.submitEnterpriseOnboardingRequest(arg0, arg1);
            return result;
        }
    }
    async submitNotaryRequest(arg0: NotaryRequest): Promise<NotarizationRecord> {
        if (this.processError) {
            try {
                const result = await this.actor.submitNotaryRequest(arg0);
                return from_candid_NotarizationRecord_n32(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.submitNotaryRequest(arg0);
            return from_candid_NotarizationRecord_n32(this._uploadFile, this._downloadFile, result);
        }
    }
    async unlockMarketplaceItem(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.unlockMarketplaceItem(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.unlockMarketplaceItem(arg0);
            return result;
        }
    }
    async updateAgentConfigs(arg0: AgentConfig): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateAgentConfigs(to_candid_AgentConfig_n65(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateAgentConfigs(to_candid_AgentConfig_n65(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async updateAgentDesign(arg0: bigint, arg1: SharedAgentDesignState): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateAgentDesign(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateAgentDesign(arg0, arg1);
            return result;
        }
    }
    async updateAgentStatus(arg0: bigint, arg1: AgentStatus): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateAgentStatus(arg0, to_candid_AgentStatus_n67(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateAgentStatus(arg0, to_candid_AgentStatus_n67(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async updateAgentVerificationStatus(arg0: Principal, arg1: bigint, arg2: VerificationStatus): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateAgentVerificationStatus(arg0, arg1, to_candid_VerificationStatus_n69(this._uploadFile, this._downloadFile, arg2));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateAgentVerificationStatus(arg0, arg1, to_candid_VerificationStatus_n69(this._uploadFile, this._downloadFile, arg2));
            return result;
        }
    }
    async updateEnterpriseRequestStatus(arg0: bigint, arg1: Variant_pending_approved_rejected, arg2: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateEnterpriseRequestStatus(arg0, to_candid_variant_n71(this._uploadFile, this._downloadFile, arg1), arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateEnterpriseRequestStatus(arg0, to_candid_variant_n71(this._uploadFile, this._downloadFile, arg1), arg2);
            return result;
        }
    }
    async updateMarketplaceItem(arg0: bigint, arg1: MarketplaceItem): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateMarketplaceItem(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateMarketplaceItem(arg0, arg1);
            return result;
        }
    }
    async updatePolicyRule(arg0: bigint, arg1: PolicyRule): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updatePolicyRule(arg0, to_candid_PolicyRule_n13(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updatePolicyRule(arg0, to_candid_PolicyRule_n13(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async updateRoadmapItem(arg0: bigint, arg1: RoadmapItem): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateRoadmapItem(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateRoadmapItem(arg0, arg1);
            return result;
        }
    }
    async verifyNotarizationHash(arg0: Uint8Array): Promise<NotarizationRecord | null> {
        if (this.processError) {
            try {
                const result = await this.actor.verifyNotarizationHash(arg0);
                return from_candid_opt_n72(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.verifyNotarizationHash(arg0);
            return from_candid_opt_n72(this._uploadFile, this._downloadFile, result);
        }
    }
    async verifyNotarizationText(arg0: string): Promise<NotarizationRecord | null> {
        if (this.processError) {
            try {
                const result = await this.actor.verifyNotarizationText(arg0);
                return from_candid_opt_n72(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.verifyNotarizationText(arg0);
            return from_candid_opt_n72(this._uploadFile, this._downloadFile, result);
        }
    }
    async whoami(): Promise<string> {
        if (this.processError) {
            try {
                const result = await this.actor.whoami();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.whoami();
            return result;
        }
    }
}
function from_candid_AgentConfig_n21(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _AgentConfig): AgentConfig {
    return from_candid_record_n22(_uploadFile, _downloadFile, value);
}
function from_candid_AgentStatus_n23(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _AgentStatus): AgentStatus {
    return from_candid_variant_n24(_uploadFile, _downloadFile, value);
}
function from_candid_DebugRoleResult_n15(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _DebugRoleResult): DebugRoleResult {
    return from_candid_record_n16(_uploadFile, _downloadFile, value);
}
function from_candid_EnterpriseOnboardingRequest_n28(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _EnterpriseOnboardingRequest): EnterpriseOnboardingRequest {
    return from_candid_record_n29(_uploadFile, _downloadFile, value);
}
function from_candid_EvidenceItem_n11(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _EvidenceItem): EvidenceItem {
    return from_candid_record_n12(_uploadFile, _downloadFile, value);
}
function from_candid_LabelSetState_n48(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _LabelSetState): LabelSetState {
    return from_candid_variant_n49(_uploadFile, _downloadFile, value);
}
function from_candid_NotarizationRecord_n32(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _NotarizationRecord): NotarizationRecord {
    return from_candid_record_n33(_uploadFile, _downloadFile, value);
}
function from_candid_PolicyRule_n57(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _PolicyRule): PolicyRule {
    return from_candid_record_n58(_uploadFile, _downloadFile, value);
}
function from_candid_Role_n18(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Role): Role {
    return from_candid_variant_n19(_uploadFile, _downloadFile, value);
}
function from_candid_TokenOperation_n43(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _TokenOperation): TokenOperation {
    return from_candid_variant_n44(_uploadFile, _downloadFile, value);
}
function from_candid_TradeOrder_n52(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _TradeOrder): TradeOrder {
    return from_candid_record_n53(_uploadFile, _downloadFile, value);
}
function from_candid_UserRole_n39(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserRole): UserRole {
    return from_candid_variant_n40(_uploadFile, _downloadFile, value);
}
function from_candid_VerificationStatus_n25(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _VerificationStatus): VerificationStatus {
    return from_candid_variant_n26(_uploadFile, _downloadFile, value);
}
function from_candid__CaffeineStorageRefillResult_n4(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: __CaffeineStorageRefillResult): _CaffeineStorageRefillResult {
    return from_candid_record_n5(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n17(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_Role]): Role | null {
    return value.length === 0 ? null : from_candid_Role_n18(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n34(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [Uint8Array]): Uint8Array | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n35(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [string]): string | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n38(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_UserProfile]): UserProfile | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n41(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_CommunityTopic]): CommunityTopic | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n45(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_EnterpriseOnboardingRequest]): EnterpriseOnboardingRequest | null {
    return value.length === 0 ? null : from_candid_EnterpriseOnboardingRequest_n28(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n46(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_EvidenceItem]): EvidenceItem | null {
    return value.length === 0 ? null : from_candid_EvidenceItem_n11(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n50(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_MarketplaceItem]): MarketplaceItem | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n56(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_PolicyRule]): PolicyRule | null {
    return value.length === 0 ? null : from_candid_PolicyRule_n57(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n59(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [bigint]): bigint | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n6(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [boolean]): boolean | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n61(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_WorkflowRun]): WorkflowRun | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n63(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_TokenDistribution]): TokenDistribution | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n7(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [bigint]): bigint | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n72(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_NotarizationRecord]): NotarizationRecord | null {
    return value.length === 0 ? null : from_candid_NotarizationRecord_n32(_uploadFile, _downloadFile, value[0]);
}
function from_candid_record_n12(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: bigint;
    owner: Principal;
    notarizationRecordId: [] | [bigint];
    description: string;
    timestamp: bigint;
}): {
    id: bigint;
    owner: Principal;
    notarizationRecordId?: bigint;
    description: string;
    timestamp: bigint;
} {
    return {
        id: value.id,
        owner: value.owner,
        notarizationRecordId: record_opt_to_undefined(from_candid_opt_n7(_uploadFile, _downloadFile, value.notarizationRecordId)),
        description: value.description,
        timestamp: value.timestamp
    };
}
function from_candid_record_n16(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    roleMapValue: [] | [_Role];
    callerText: string;
    isAdmin: boolean;
}): {
    roleMapValue?: Role;
    callerText: string;
    isAdmin: boolean;
} {
    return {
        roleMapValue: record_opt_to_undefined(from_candid_opt_n17(_uploadFile, _downloadFile, value.roleMapValue)),
        callerText: value.callerText,
        isAdmin: value.isAdmin
    };
}
function from_candid_record_n22(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    issueDate: bigint;
    status: _AgentStatus;
    maxSessions: [] | [bigint];
    expiryTimestamp: bigint;
    approvalRequired: boolean;
    capabilities: Array<string>;
    name: string;
    roleDescription: string;
    policyScope: string;
    verificationStatus: _VerificationStatus;
    maxBudget: bigint;
}): {
    issueDate: bigint;
    status: AgentStatus;
    maxSessions?: bigint;
    expiryTimestamp: bigint;
    approvalRequired: boolean;
    capabilities: Array<string>;
    name: string;
    roleDescription: string;
    policyScope: string;
    verificationStatus: VerificationStatus;
    maxBudget: bigint;
} {
    return {
        issueDate: value.issueDate,
        status: from_candid_AgentStatus_n23(_uploadFile, _downloadFile, value.status),
        maxSessions: record_opt_to_undefined(from_candid_opt_n7(_uploadFile, _downloadFile, value.maxSessions)),
        expiryTimestamp: value.expiryTimestamp,
        approvalRequired: value.approvalRequired,
        capabilities: value.capabilities,
        name: value.name,
        roleDescription: value.roleDescription,
        policyScope: value.policyScope,
        verificationStatus: from_candid_VerificationStatus_n25(_uploadFile, _downloadFile, value.verificationStatus),
        maxBudget: value.maxBudget
    };
}
function from_candid_record_n29(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: bigint;
    contract: string;
    user: Principal;
    company: string;
    onboardingStatus: {
        pending: null;
    } | {
        approved: null;
    } | {
        rejected: null;
    };
    notes: string;
    timestamp: _Time;
}): {
    id: bigint;
    contract: string;
    user: Principal;
    company: string;
    onboardingStatus: Variant_pending_approved_rejected;
    notes: string;
    timestamp: Time;
} {
    return {
        id: value.id,
        contract: value.contract,
        user: value.user,
        company: value.company,
        onboardingStatus: from_candid_variant_n30(_uploadFile, _downloadFile, value.onboardingStatus),
        notes: value.notes,
        timestamp: value.timestamp
    };
}
function from_candid_record_n33(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: bigint;
    contentHash: [] | [Uint8Array];
    contentText: [] | [string];
    owner: Principal;
    timestamp: bigint;
}): {
    id: bigint;
    contentHash?: Uint8Array;
    contentText?: string;
    owner: Principal;
    timestamp: bigint;
} {
    return {
        id: value.id,
        contentHash: record_opt_to_undefined(from_candid_opt_n34(_uploadFile, _downloadFile, value.contentHash)),
        contentText: record_opt_to_undefined(from_candid_opt_n35(_uploadFile, _downloadFile, value.contentText)),
        owner: value.owner,
        timestamp: value.timestamp
    };
}
function from_candid_record_n5(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    success: [] | [boolean];
    topped_up_amount: [] | [bigint];
}): {
    success?: boolean;
    topped_up_amount?: bigint;
} {
    return {
        success: record_opt_to_undefined(from_candid_opt_n6(_uploadFile, _downloadFile, value.success)),
        topped_up_amount: record_opt_to_undefined(from_candid_opt_n7(_uploadFile, _downloadFile, value.topped_up_amount))
    };
}
function from_candid_record_n53(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: bigint;
    status: {
        cancelled: null;
    } | {
        open: null;
    } | {
        filled: null;
    };
    user: Principal;
    orderType: {
        buy: null;
    } | {
        sell: null;
    };
    timestamp: bigint;
    tokenPair: string;
    price: bigint;
    amount: bigint;
}): {
    id: bigint;
    status: Variant_cancelled_open_filled;
    user: Principal;
    orderType: Variant_buy_sell;
    timestamp: bigint;
    tokenPair: string;
    price: bigint;
    amount: bigint;
} {
    return {
        id: value.id,
        status: from_candid_variant_n54(_uploadFile, _downloadFile, value.status),
        user: value.user,
        orderType: from_candid_variant_n55(_uploadFile, _downloadFile, value.orderType),
        timestamp: value.timestamp,
        tokenPair: value.tokenPair,
        price: value.price,
        amount: value.amount
    };
}
function from_candid_record_n58(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    ruleType: string;
    active: boolean;
    name: string;
    description: string;
    enforced: boolean;
    scope: string;
    criteria: [] | [string];
    expiry: [] | [bigint];
    allowedActions: Array<string>;
}): {
    ruleType: string;
    active: boolean;
    name: string;
    description: string;
    enforced: boolean;
    scope: string;
    criteria?: string;
    expiry?: bigint;
    allowedActions: Array<string>;
} {
    return {
        ruleType: value.ruleType,
        active: value.active,
        name: value.name,
        description: value.description,
        enforced: value.enforced,
        scope: value.scope,
        criteria: record_opt_to_undefined(from_candid_opt_n35(_uploadFile, _downloadFile, value.criteria)),
        expiry: record_opt_to_undefined(from_candid_opt_n59(_uploadFile, _downloadFile, value.expiry)),
        allowedActions: value.allowedActions
    };
}
function from_candid_record_n62(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    timeTokenDistributions: [] | [_TokenDistribution];
    travAiTokenDistributions: [] | [_TokenDistribution];
    travTokenDistributions: [] | [_TokenDistribution];
    timeAiTokenDistributions: [] | [_TokenDistribution];
    miningTokenDistributions: [] | [_TokenDistribution];
}): {
    timeTokenDistributions?: TokenDistribution;
    travAiTokenDistributions?: TokenDistribution;
    travTokenDistributions?: TokenDistribution;
    timeAiTokenDistributions?: TokenDistribution;
    miningTokenDistributions?: TokenDistribution;
} {
    return {
        timeTokenDistributions: record_opt_to_undefined(from_candid_opt_n63(_uploadFile, _downloadFile, value.timeTokenDistributions)),
        travAiTokenDistributions: record_opt_to_undefined(from_candid_opt_n63(_uploadFile, _downloadFile, value.travAiTokenDistributions)),
        travTokenDistributions: record_opt_to_undefined(from_candid_opt_n63(_uploadFile, _downloadFile, value.travTokenDistributions)),
        timeAiTokenDistributions: record_opt_to_undefined(from_candid_opt_n63(_uploadFile, _downloadFile, value.timeAiTokenDistributions)),
        miningTokenDistributions: record_opt_to_undefined(from_candid_opt_n63(_uploadFile, _downloadFile, value.miningTokenDistributions))
    };
}
function from_candid_tuple_n37(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [Principal, _Role]): [Principal, Role] {
    return [
        value[0],
        from_candid_Role_n18(_uploadFile, _downloadFile, value[1])
    ];
}
function from_candid_variant_n19(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    admin: null;
} | {
    user: null;
}): Role {
    return "admin" in value ? Role.admin : "user" in value ? Role.user : value;
}
function from_candid_variant_n24(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    active: null;
} | {
    pending: null;
} | {
    suspended: null;
}): AgentStatus {
    return "active" in value ? AgentStatus.active : "pending" in value ? AgentStatus.pending : "suspended" in value ? AgentStatus.suspended : value;
}
function from_candid_variant_n26(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    verified: null;
} | {
    pending: null;
} | {
    unverified: null;
} | {
    suspended: null;
}): VerificationStatus {
    return "verified" in value ? VerificationStatus.verified : "pending" in value ? VerificationStatus.pending : "unverified" in value ? VerificationStatus.unverified : "suspended" in value ? VerificationStatus.suspended : value;
}
function from_candid_variant_n30(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    pending: null;
} | {
    approved: null;
} | {
    rejected: null;
}): Variant_pending_approved_rejected {
    return "pending" in value ? Variant_pending_approved_rejected.pending : "approved" in value ? Variant_pending_approved_rejected.approved : "rejected" in value ? Variant_pending_approved_rejected.rejected : value;
}
function from_candid_variant_n40(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
}): UserRole {
    return "admin" in value ? UserRole.admin : "user" in value ? UserRole.user : "guest" in value ? UserRole.guest : value;
}
function from_candid_variant_n44(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    trade: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        fromToken: bigint;
        amount: bigint;
        toToken: bigint;
    };
} | {
    burn: {
        timestamp: bigint;
        amount: bigint;
    };
} | {
    mint: {
        to: Principal;
        timestamp: bigint;
        amount: bigint;
    };
} | {
    transfer: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        amount: bigint;
    };
} | {
    conversion: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        fromToken: bigint;
        amount: bigint;
        toToken: bigint;
    };
}): {
    __kind__: "trade";
    trade: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        fromToken: bigint;
        amount: bigint;
        toToken: bigint;
    };
} | {
    __kind__: "burn";
    burn: {
        timestamp: bigint;
        amount: bigint;
    };
} | {
    __kind__: "mint";
    mint: {
        to: Principal;
        timestamp: bigint;
        amount: bigint;
    };
} | {
    __kind__: "transfer";
    transfer: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        amount: bigint;
    };
} | {
    __kind__: "conversion";
    conversion: {
        to: Principal;
        from: Principal;
        timestamp: bigint;
        fromToken: bigint;
        amount: bigint;
        toToken: bigint;
    };
} {
    return "trade" in value ? {
        __kind__: "trade",
        trade: value.trade
    } : "burn" in value ? {
        __kind__: "burn",
        burn: value.burn
    } : "mint" in value ? {
        __kind__: "mint",
        mint: value.mint
    } : "transfer" in value ? {
        __kind__: "transfer",
        transfer: value.transfer
    } : "conversion" in value ? {
        __kind__: "conversion",
        conversion: value.conversion
    } : value;
}
function from_candid_variant_n49(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    notFreezed: null;
} | {
    freezed: null;
}): LabelSetState {
    return "notFreezed" in value ? LabelSetState.notFreezed : "freezed" in value ? LabelSetState.freezed : value;
}
function from_candid_variant_n54(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    cancelled: null;
} | {
    open: null;
} | {
    filled: null;
}): Variant_cancelled_open_filled {
    return "cancelled" in value ? Variant_cancelled_open_filled.cancelled : "open" in value ? Variant_cancelled_open_filled.open : "filled" in value ? Variant_cancelled_open_filled.filled : value;
}
function from_candid_variant_n55(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    buy: null;
} | {
    sell: null;
}): Variant_buy_sell {
    return "buy" in value ? Variant_buy_sell.buy : "sell" in value ? Variant_buy_sell.sell : value;
}
function from_candid_vec_n20(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_AgentConfig>): Array<AgentConfig> {
    return value.map((x)=>from_candid_AgentConfig_n21(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n27(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_EnterpriseOnboardingRequest>): Array<EnterpriseOnboardingRequest> {
    return value.map((x)=>from_candid_EnterpriseOnboardingRequest_n28(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n31(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_NotarizationRecord>): Array<NotarizationRecord> {
    return value.map((x)=>from_candid_NotarizationRecord_n32(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n36(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[Principal, _Role]>): Array<[Principal, Role]> {
    return value.map((x)=>from_candid_tuple_n37(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n42(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_TokenOperation>): Array<TokenOperation> {
    return value.map((x)=>from_candid_TokenOperation_n43(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n47(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_EvidenceItem>): Array<EvidenceItem> {
    return value.map((x)=>from_candid_EvidenceItem_n11(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n51(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_TradeOrder>): Array<TradeOrder> {
    return value.map((x)=>from_candid_TradeOrder_n52(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n60(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_PolicyRule>): Array<PolicyRule> {
    return value.map((x)=>from_candid_PolicyRule_n57(_uploadFile, _downloadFile, x));
}
function to_candid_AgentConfig_n65(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: AgentConfig): _AgentConfig {
    return to_candid_record_n66(_uploadFile, _downloadFile, value);
}
function to_candid_AgentStatus_n67(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: AgentStatus): _AgentStatus {
    return to_candid_variant_n68(_uploadFile, _downloadFile, value);
}
function to_candid_PolicyRule_n13(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: PolicyRule): _PolicyRule {
    return to_candid_record_n14(_uploadFile, _downloadFile, value);
}
function to_candid_UserRole_n8(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): _UserRole {
    return to_candid_variant_n9(_uploadFile, _downloadFile, value);
}
function to_candid_VerificationStatus_n69(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: VerificationStatus): _VerificationStatus {
    return to_candid_variant_n70(_uploadFile, _downloadFile, value);
}
function to_candid__CaffeineStorageRefillInformation_n2(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _CaffeineStorageRefillInformation): __CaffeineStorageRefillInformation {
    return to_candid_record_n3(_uploadFile, _downloadFile, value);
}
function to_candid_opt_n1(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _CaffeineStorageRefillInformation | null): [] | [__CaffeineStorageRefillInformation] {
    return value === null ? candid_none() : candid_some(to_candid__CaffeineStorageRefillInformation_n2(_uploadFile, _downloadFile, value));
}
function to_candid_opt_n10(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: bigint | null): [] | [bigint] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_record_n14(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    ruleType: string;
    active: boolean;
    name: string;
    description: string;
    enforced: boolean;
    scope: string;
    criteria?: string;
    expiry?: bigint;
    allowedActions: Array<string>;
}): {
    ruleType: string;
    active: boolean;
    name: string;
    description: string;
    enforced: boolean;
    scope: string;
    criteria: [] | [string];
    expiry: [] | [bigint];
    allowedActions: Array<string>;
} {
    return {
        ruleType: value.ruleType,
        active: value.active,
        name: value.name,
        description: value.description,
        enforced: value.enforced,
        scope: value.scope,
        criteria: value.criteria ? candid_some(value.criteria) : candid_none(),
        expiry: value.expiry ? candid_some(value.expiry) : candid_none(),
        allowedActions: value.allowedActions
    };
}
function to_candid_record_n3(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    proposed_top_up_amount?: bigint;
}): {
    proposed_top_up_amount: [] | [bigint];
} {
    return {
        proposed_top_up_amount: value.proposed_top_up_amount ? candid_some(value.proposed_top_up_amount) : candid_none()
    };
}
function to_candid_record_n66(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    issueDate: bigint;
    status: AgentStatus;
    maxSessions?: bigint;
    expiryTimestamp: bigint;
    approvalRequired: boolean;
    capabilities: Array<string>;
    name: string;
    roleDescription: string;
    policyScope: string;
    verificationStatus: VerificationStatus;
    maxBudget: bigint;
}): {
    issueDate: bigint;
    status: _AgentStatus;
    maxSessions: [] | [bigint];
    expiryTimestamp: bigint;
    approvalRequired: boolean;
    capabilities: Array<string>;
    name: string;
    roleDescription: string;
    policyScope: string;
    verificationStatus: _VerificationStatus;
    maxBudget: bigint;
} {
    return {
        issueDate: value.issueDate,
        status: to_candid_AgentStatus_n67(_uploadFile, _downloadFile, value.status),
        maxSessions: value.maxSessions ? candid_some(value.maxSessions) : candid_none(),
        expiryTimestamp: value.expiryTimestamp,
        approvalRequired: value.approvalRequired,
        capabilities: value.capabilities,
        name: value.name,
        roleDescription: value.roleDescription,
        policyScope: value.policyScope,
        verificationStatus: to_candid_VerificationStatus_n69(_uploadFile, _downloadFile, value.verificationStatus),
        maxBudget: value.maxBudget
    };
}
function to_candid_variant_n64(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Variant_buy_sell): {
    buy: null;
} | {
    sell: null;
} {
    return value == Variant_buy_sell.buy ? {
        buy: null
    } : value == Variant_buy_sell.sell ? {
        sell: null
    } : value;
}
function to_candid_variant_n68(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: AgentStatus): {
    active: null;
} | {
    pending: null;
} | {
    suspended: null;
} {
    return value == AgentStatus.active ? {
        active: null
    } : value == AgentStatus.pending ? {
        pending: null
    } : value == AgentStatus.suspended ? {
        suspended: null
    } : value;
}
function to_candid_variant_n70(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: VerificationStatus): {
    verified: null;
} | {
    pending: null;
} | {
    unverified: null;
} | {
    suspended: null;
} {
    return value == VerificationStatus.verified ? {
        verified: null
    } : value == VerificationStatus.pending ? {
        pending: null
    } : value == VerificationStatus.unverified ? {
        unverified: null
    } : value == VerificationStatus.suspended ? {
        suspended: null
    } : value;
}
function to_candid_variant_n71(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Variant_pending_approved_rejected): {
    pending: null;
} | {
    approved: null;
} | {
    rejected: null;
} {
    return value == Variant_pending_approved_rejected.pending ? {
        pending: null
    } : value == Variant_pending_approved_rejected.approved ? {
        approved: null
    } : value == Variant_pending_approved_rejected.rejected ? {
        rejected: null
    } : value;
}
function to_candid_variant_n9(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
} {
    return value == UserRole.admin ? {
        admin: null
    } : value == UserRole.user ? {
        user: null
    } : value == UserRole.guest ? {
        guest: null
    } : value;
}
export interface CreateActorOptions {
    agent?: Agent;
    agentOptions?: HttpAgentOptions;
    actorOptions?: ActorConfig;
    processError?: (error: unknown) => never;
}
export function createActor(canisterId: string, _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, options: CreateActorOptions = {}): Backend {
    const agent = options.agent || HttpAgent.createSync({
        ...options.agentOptions
    });
    if (options.agent && options.agentOptions) {
        console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.");
    }
    const actor = Actor.createActor<_SERVICE>(idlFactory, {
        agent,
        canisterId: canisterId,
        ...options.actorOptions
    });
    return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
